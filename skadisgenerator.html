<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SKÅDIS Generator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #001f3f;
            --accent-primary: #ff851b;
            --accent-hover: #ffa64d;
            --text-primary: #ffffff;
            --grid-size: 80px;
            --grid-color: rgba(255, 255, 255, 0.2);
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
            background-image:
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            background-position: 0 0;
        }
        
        .container {
            width: 100%;
            max-width: none;
            margin: 0;
            padding: 0;
            position: relative;
            z-index: 1;
        }
        
        header {
            text-align: left;
            padding: 0 var(--grid-size);
            border-bottom: none;
            margin: 0;
        }
        
        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
            letter-spacing: 2px;
            text-transform: uppercase;
            line-height: var(--grid-size);
            height: var(--grid-size);
        }
        
        .back-arrow {
            color: var(--accent-primary);
            text-decoration: none;
            margin-right: 8px;
        }
        
        .back-arrow:hover {
            color: #ffa64d;
        }
        
        .tabs {
            display: flex;
            gap: var(--grid-size);
            margin-top: 0px;
        }
        
        .tab {
            width: calc(var(--grid-size) * 2);
            height: var(--grid-size);
            padding: 0;
            background: var(--bg-primary);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tab:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        
        .tab.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: calc(var(--grid-size) * 5) 1fr;
            gap: var(--grid-size);
            align-items: start;
            padding: var(--grid-size);
        }
        
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .control-panel {
            padding: 0;
            position: sticky;
            top: var(--grid-size);
            width: calc(var(--grid-size) * 5);
        }
        
        .control-group {
            height: var(--grid-size);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding-top: 22px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 700;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-primary);
        }
        
        .control-value {
            color: var(--accent-primary);
            font-weight: 700;
            font-size: 0.85rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
            display: block;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--accent-hover);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            cursor: pointer;
            border: none;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 0;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            user-select: none;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent-primary);
        }
        
        .btn-group {
            margin-top: 0;
            display: flex;
            flex-direction: column;
            gap: var(--grid-size);
        }
        
        .btn {
            width: calc(var(--grid-size) * 5);
            height: var(--grid-size);
            padding: 0;
            background: var(--bg-primary);
            border: 1px solid var(--accent-primary);
            color: var(--accent-primary);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .btn:active {
            transform: scale(0.98);
        }
        
        .preview-area {
            background: transparent;
            border: none;
            padding: 0;
            min-height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: visible;
        }
        
        canvas {
            max-width: 100%;
            max-height: 100%;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="index.html" class="back-arrow">↩</a> SKÅDIS</h1>
            <div class="tabs">
                <button class="tab active" data-type="container">Containers</button>
                <button class="tab" data-type="simpleHook">Simple Hook</button>
                <button class="tab" data-type="doubleHook">Double Hook</button>
                <button class="tab" data-type="holeHanger">Hole Hanger</button>
            </div>
        </header>
        
        <div class="main-grid">
            <!-- CONTAINERS CONTROLS -->
            <div class="control-panel" id="containerControls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Width (mm)</span>
                        <span class="control-value" id="widthValue">200</span>
                    </label>
                    <input type="range" id="width" min="80" max="400" value="200" step="40">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Depth (mm)</span>
                        <span class="control-value" id="depthValue">80</span>
                    </label>
                    <input type="range" id="depth" min="40" max="200" value="80" step="10">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Height (mm)</span>
                        <span class="control-value" id="heightValue">40</span>
                    </label>
                    <input type="range" id="height" min="20" max="100" value="40" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Width Divisions</span>
                        <span class="control-value" id="divisionsValue">2</span>
                    </label>
                    <input type="range" id="divisions" min="1" max="6" value="2" step="1">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Depth Divisions</span>
                        <span class="control-value" id="depthDivisionsValue">1</span>
                    </label>
                    <input type="range" id="depthDivisions" min="1" max="4" value="1" step="1">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Wall Thickness (mm)</span>
                        <span class="control-value" id="wallThicknessValue">2.0</span>
                    </label>
                    <input type="range" id="wallThickness" min="1.0" max="4.0" value="2.0" step="0.2">
                </div>
                
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="addLid" checked>
                        <span>Add Sliding Lid</span>
                    </label>
                </div>
                
                <div class="btn-group">
                    <button class="btn" onclick="generate3MF()">Export .3MF</button>
                    <button class="btn" onclick="generateSTL()">Export .STL</button>
                </div>
            </div>
            
            <!-- HOLE HANGER CONTROLS -->
            <div class="control-panel hidden" id="holeHangerControls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Width (mm)</span>
                        <span class="control-value" id="holeWidthValue">200</span>
                    </label>
                    <input type="range" id="holeWidth" min="80" max="400" value="200" step="40">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Depth (mm)</span>
                        <span class="control-value" id="holeDepthValue">30</span>
                    </label>
                    <input type="range" id="holeDepth" min="20" max="80" value="30" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Strip Height (mm)</span>
                        <span class="control-value" id="stripHeightValue">20</span>
                    </label>
                    <input type="range" id="stripHeight" min="15" max="40" value="20" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Hole Count</span>
                        <span class="control-value" id="holeCountValue">3</span>
                    </label>
                    <input type="range" id="holeCount" min="1" max="8" value="3" step="1">
                </div>
                
                <!-- Dynamic hole controls will be inserted here -->
                <div id="dynamicHoleControls"></div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Wall Thickness (mm)</span>
                        <span class="control-value" id="holeWallThicknessValue">2.0</span>
                    </label>
                    <input type="range" id="holeWallThickness" min="1.0" max="4.0" value="2.0" step="0.2">
                </div>
                
                <div class="btn-group">
                    <button class="btn" onclick="generate3MF()">Export .3MF</button>
                    <button class="btn" onclick="generateSTL()">Export .STL</button>
                </div>
            </div>
            
            <!-- SIMPLE HOOK CONTROLS -->
            <div class="control-panel hidden" id="simpleHookControls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Hook Width (mm)</span>
                        <span class="control-value" id="simpleHookDepthValue">40</span>
                    </label>
                    <input type="range" id="simpleHookDepth" min="10" max="100" value="40" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Leg Height (mm)</span>
                        <span class="control-value" id="simpleHookLegHeightValue">30</span>
                    </label>
                    <input type="range" id="simpleHookLegHeight" min="5" max="100" value="30" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Extrusion Depth (mm)</span>
                        <span class="control-value" id="simpleHookExtrusionValue">6</span>
                    </label>
                    <input type="range" id="simpleHookExtrusion" min="2" max="20" value="6" step="1">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Line Thickness (mm)</span>
                        <span class="control-value" id="simpleHookThicknessValue">3</span>
                    </label>
                    <input type="range" id="simpleHookThickness" min="1" max="10" value="3" step="0.5">
                </div>
                
                <div class="btn-group">
                    <button class="btn" onclick="generate3MF()">Export .3MF</button>
                    <button class="btn" onclick="generateSTL()">Export .STL</button>
                </div>
            </div>
            
            <!-- DOUBLE HOOK CONTROLS -->
            <div class="control-panel hidden" id="doubleHookControls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Hook Width (mm)</span>
                        <span class="control-value" id="doubleHookDepthValue">40</span>
                    </label>
                    <input type="range" id="doubleHookDepth" min="10" max="100" value="40" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Leg Height (mm)</span>
                        <span class="control-value" id="doubleHookLegHeightValue">30</span>
                    </label>
                    <input type="range" id="doubleHookLegHeight" min="5" max="100" value="30" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Extrusion Depth (mm)</span>
                        <span class="control-value" id="doubleHookExtrusionValue">6</span>
                    </label>
                    <input type="range" id="doubleHookExtrusion" min="2" max="20" value="6" step="1">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Hook Spacing (mm)</span>
                        <span class="control-value" id="doubleHookSpacingValue">40</span>
                    </label>
                    <input type="range" id="doubleHookSpacing" min="20" max="150" value="40" step="10">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Line Thickness (mm)</span>
                        <span class="control-value" id="doubleHookThicknessValue">3</span>
                    </label>
                    <input type="range" id="doubleHookThickness" min="1" max="10" value="3" step="0.5">
                </div>
                
                <div class="btn-group">
                    <button class="btn" onclick="generate3MF()">Export .3MF</button>
                    <button class="btn" onclick="generateSTL()">Export .STL</button>
                </div>
            </div>
            
            <!-- HOOK HANGER CONTROLS -->
            <div class="control-panel hidden" id="hookHangerControls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Back Width (mm)</span>
                        <span class="control-value" id="hookBackWidthValue">40</span>
                    </label>
                    <input type="range" id="hookBackWidth" min="40" max="120" value="40" step="40">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Hook Depth (mm)</span>
                        <span class="control-value" id="hookDepthValue">40</span>
                    </label>
                    <input type="range" id="hookDepth" min="20" max="80" value="40" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Hook Height (mm)</span>
                        <span class="control-value" id="hookHeightValue">30</span>
                    </label>
                    <input type="range" id="hookHeight" min="20" max="60" value="30" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Hook Thickness (mm)</span>
                        <span class="control-value" id="hookThicknessValue">6</span>
                    </label>
                    <input type="range" id="hookThickness" min="4" max="10" value="6" step="1">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Tip Diameter (mm)</span>
                        <span class="control-value" id="tipDiameterValue">8</span>
                    </label>
                    <input type="range" id="tipDiameter" min="6" max="14" value="8" step="1">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Back Height (mm)</span>
                        <span class="control-value" id="hookBackHeightValue">40</span>
                    </label>
                    <input type="range" id="hookBackHeight" min="30" max="80" value="40" step="5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <span>Wall Thickness (mm)</span>
                        <span class="control-value" id="hookWallThicknessValue">2.0</span>
                    </label>
                    <input type="range" id="hookWallThickness" min="1.0" max="4.0" value="2.0" step="0.2">
                </div>
                
                <div class="btn-group">
                    <button class="btn" onclick="generate3MF()">Export .3MF</button>
                    <button class="btn" onclick="generateSTL()">Export .STL</button>
                </div>
            </div>
            
            <div class="preview-area">
                <canvas id="canvas"></canvas>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/lines/LineSegmentsGeometry.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/lines/LineMaterial.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/lines/LineSegments2.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let currentModel;
        let currentType = 'container';
        
        // Clip OBJ data (same for all types)
        const clipObjData = `# Created by FreeCAD <https://www.freecad.org>
v -17.923225 12.913093 4.000000
v -17.923225 8.913093 0.000000
v -17.923225 8.913093 14.500000
v -17.923225 12.913093 14.500000
v -13.423226 8.913093 0.000000
v -16.423225 9.606767 0.693674
v -14.923226 9.606767 0.693674
v -18.164761 13.045250 4.132157
v -18.372843 13.225547 4.312454
v -18.538036 13.445809 4.532717
v -17.250830 15.388205 6.475111
v -17.695194 15.372083 6.458990
v -17.473709 15.399387 6.486294
v -17.033192 15.338868 6.425775
v -17.931633 15.297633 6.384540
v -16.423225 14.922552 6.009459
v -18.652855 13.696053 4.782960
v -18.712093 13.964931 5.051839
v -18.713064 14.240257 5.327164
v -18.655724 14.509547 5.596454
v -18.542673 14.760593 5.847501
v -18.379036 14.982016 6.068923
v -16.525078 15.033941 6.120848
v -18.172230 15.163775 6.250682
v -16.827276 15.252847 6.339754
v -16.639217 15.132703 6.219610
v -13.423226 12.913093 4.000000
v -13.160264 13.062304 4.149210
v -13.287354 12.979959 4.066865
v -12.939292 13.268710 4.355617
v -14.923226 14.913093 6.000000
v -12.772510 13.520932 4.607839
v -12.669102 13.805079 4.891985
v -12.634765 14.105500 5.192408
v -12.671390 14.405652 5.492559
v -13.790252 15.382183 6.469090
v -14.214039 15.355816 6.442723
v -13.992033 15.387225 6.474132
v -12.776958 14.689002 5.775909
v -13.591735 15.345691 6.432598
v -14.450099 15.276417 6.363323
v -12.924056 14.914113 6.001020
v -13.401352 15.278644 6.365551
v -13.063366 15.060174 6.147081
v -14.682685 15.141447 6.228354
v -13.223777 15.182687 6.269593
v -16.423225 14.922552 14.500000
v -16.648300 15.139614 14.500000
v -16.918898 15.296304 14.500000
v -17.219196 15.383459 14.500000
v -17.531633 15.395983 14.500000
v -17.837944 15.333143 14.500000
v -18.120214 15.198615 14.500000
v -18.361942 15.000263 14.500000
v -18.548988 14.749688 14.500000
v -18.670420 14.461539 14.500000
v -18.719133 14.152668 14.500000
v -18.692282 13.841133 14.500000
v -18.591434 13.545153 14.500000
v -18.422491 13.282032 14.500000
v -18.195326 13.067157 14.500000
v -16.423225 9.606767 14.500000
v -13.423226 8.913093 14.500000
v -14.923226 9.606767 14.500000
v -13.423226 12.913093 14.500000
v -14.430047 15.285198 14.500000
v -13.153111 13.067598 14.500000
v -14.699269 15.129142 14.500000
v -14.923226 14.913093 14.500000
v -12.661437 13.839741 14.500000
v -12.927915 13.282356 14.500000
v -12.760774 13.544840 14.500000
v -13.820344 15.384950 14.500000
v -14.131263 15.372158 14.500000
v -12.685058 14.457098 14.500000
v -12.635697 14.149856 14.500000
v -13.234295 15.189413 14.500000
v -13.515426 15.322826 14.500000
v -12.993347 14.992491 14.500000
v -12.806639 14.743546 14.500000
vn -1.000000 -0.000000 0.000000
vn -1.000000 0.000000 0.000000
vn 0.000000 0.707107 -0.707107
vn 0.000000 0.707107 -0.707107
vn 0.000000 0.707107 -0.707107
vn 0.000000 0.707107 -0.707107
vn 0.000000 0.707107 -0.707107
vn 0.000001 0.707098 -0.707116
vn 0.000000 0.707109 -0.707105
vn 0.000000 0.707107 -0.707107
vn -0.000000 0.707107 -0.707107
vn -0.000000 0.707107 -0.707107
vn 0.000000 0.707106 -0.707107
vn 0.000000 0.707107 -0.707107
vn -0.000000 0.707108 -0.707106
vn -0.000000 0.707107 -0.707107
vn -0.000000 0.707107 -0.707107
vn -0.000000 0.707106 -0.707108
vn -0.000000 0.707107 -0.707107
vn 0.000000 0.707105 -0.707108
vn 0.000000 0.707107 -0.707106
vn 0.000000 0.707109 -0.707105
vn 0.000000 0.707106 -0.707108
vn 0.000000 0.707107 -0.707107
vn -0.000011 0.707115 -0.707099
vn -0.000003 0.707108 -0.707105
vn -0.000000 0.707107 -0.707107
vn -0.000000 0.707107 -0.707107
vn -0.000000 0.707107 -0.707107
vn 0.000000 0.707107 -0.707106
vn -0.000000 0.707106 -0.707107
vn 0.000001 0.707102 -0.707112
vn 0.000000 0.707107 -0.707106
vn 0.000001 0.707108 -0.707105
vn 0.000001 0.707108 -0.707106
vn 0.000000 0.707107 -0.707107
vn 0.000000 0.707110 -0.707104
vn 0.000000 0.707107 -0.707107
vn 0.000000 0.707107 -0.707107
vn 0.000000 0.707109 -0.707105
vn -0.000000 0.707105 -0.707109
vn -0.000000 0.707104 -0.707110
vn -0.000000 0.707107 -0.707107
vn 0.000000 0.707107 -0.707107
vn 0.737993 0.674809 -0.000000
vn 0.694178 0.719803 0.001131
vn 0.654370 0.756174 0.000087
vn 0.501103 0.865387 0.001018
vn 0.538323 0.842739 -0.000113
vn 0.278727 0.960370 0.001117
vn 0.385258 0.922809 -0.000589
vn 0.221017 0.975270 -0.000295
vn 0.040052 0.999197 0.000714
vn 0.050131 0.998743 0.000393
vn -0.200964 0.979598 0.001176
vn -0.122297 0.992493 -0.000462
vn -0.430230 0.902719 0.001017
vn -0.300138 0.953895 -0.000709
vn -0.634338 0.773056 0.000735
vn -0.485911 0.874008 -0.000627
vn -0.801357 0.598186 0.000330
vn -0.660015 0.751252 -0.000288
vn -0.804293 0.594233 0.000162
vn -0.921514 0.388344 0.000573
vn -0.911758 0.410728 -0.000148
vn -0.987790 0.155789 0.000834
vn -0.977973 0.208731 -0.000489
vn -0.996306 -0.085873 0.000964
vn -0.999996 -0.002837 -0.000689
vn -0.946564 -0.322516 0.000975
vn -0.976739 -0.214430 -0.000762
vn -0.841477 -0.540292 0.000877
vn -0.909167 -0.416431 -0.000720
vn -0.800282 -0.599624 -0.000575
vn -0.687181 -0.726486 0.000679
vn -0.655011 -0.755619 -0.000334
vn -0.492707 -0.870195 0.000386
vn -0.480002 -0.877267 0.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 0.000000 1.000000
vn 0.000000 -0.000000 1.000000
vn 0.000000 -1.000000 0.000000
vn 0.000000 -1.000000 0.000000
vn 1.000000 0.000000 0.000000
vn 1.000000 -0.000000 0.000000
vn 0.441549 -0.897237 0.000000
vn 0.496511 -0.868030 0.000903
vn 0.543742 -0.839253 0.000054
vn 0.690136 -0.723679 0.000199
vn 0.682660 -0.730736 -0.000098
vn 0.843507 -0.537118 0.000297
vn 0.834218 -0.551435 -0.000194
vn 0.947679 -0.319223 0.000396
vn 0.939799 -0.341727 -0.000289
vn 0.996573 -0.082716 0.000494
vn 0.993575 -0.113177 -0.000384
vn 0.987339 0.158622 0.000592
vn 0.992580 0.121596 -0.000480
vn 0.920515 0.390707 0.000689
vn 0.936886 0.349635 -0.000575
vn 0.800000 0.599999 0.000989
vn 0.836860 0.547417 -0.000575
vn 0.632820 0.774298 0.000969
vn 0.723398 0.690431 -0.000469
vn 0.607028 0.794680 0.000126
vn 0.428732 0.903431 0.001105
vn 0.475356 0.879793 -0.000112
vn 0.199636 0.979870 0.000889
vn 0.332027 0.943270 -0.000467
vn 0.180856 0.983510 0.000339
vn -0.041107 0.999154 0.001163
vn 0.024974 0.999688 -0.000251
vn -0.279450 0.960160 0.000923
vn -0.140005 0.990151 -0.000570
vn -0.501496 0.865160 0.000302
vn -0.318729 0.947846 -0.000237
vn -0.502034 0.864848 0.000280
vn -0.694286 0.719699 -0.000321
vn -0.688496 0.725240 0.000000
vn -1.000000 -0.000000 -0.000000
vn -1.000000 -0.000000 0.000000
vn 0.000000 1.000000 -0.000000
vn 0.000000 1.000000 0.000000
vn 1.000000 0.000000 -0.000000
vn 1.000000 0.000000 0.000000
f 1//1 2//1 3//1
f 1//2 3//2 4//2
f 5//3 6//3 7//3
f 5//4 2//4 6//4
f 1//5 8//5 9//5
f 1//6 6//6 2//6
f 10//7 1//7 9//7
f 11//8 12//8 13//8
f 14//9 15//9 12//9
f 14//10 12//10 11//10
f 16//11 10//11 17//11
f 16//12 17//12 18//12
f 16//13 18//13 19//13
f 16//14 19//14 20//14
f 16//15 20//15 21//15
f 16//16 21//16 22//16
f 16//17 1//17 10//17
f 23//18 22//18 24//18
f 23//19 16//19 22//19
f 25//20 24//20 15//20
f 25//21 15//21 14//21
f 26//22 23//22 24//22
f 26//23 24//23 25//23
f 27//24 5//24 7//24
f 28//25 29//25 27//25
f 30//26 28//26 27//26
f 31//27 30//27 27//27
f 32//28 30//28 31//28
f 33//29 32//29 31//29
f 34//30 33//30 31//30
f 35//31 34//31 31//31
f 36//32 37//32 38//32
f 39//33 35//33 31//33
f 40//34 37//34 36//34
f 40//35 41//35 37//35
f 42//36 39//36 31//36
f 43//37 41//37 40//37
f 44//38 31//38 45//38
f 44//39 42//39 31//39
f 46//40 41//40 43//40
f 46//41 45//41 41//41
f 46//42 44//42 45//42
f 16//43 6//43 1//43
f 7//44 31//44 27//44
f 16//45 23//45 47//45
f 47//46 23//46 48//46
f 23//47 26//47 48//47
f 48//48 25//48 49//48
f 26//49 25//49 48//49
f 49//50 14//50 50//50
f 25//51 14//51 49//51
f 14//52 11//52 50//52
f 50//53 13//53 51//53
f 11//54 13//54 50//54
f 51//55 12//55 52//55
f 13//56 12//56 51//56
f 52//57 15//57 53//57
f 12//58 15//58 52//58
f 53//59 24//59 54//59
f 15//60 24//60 53//60
f 54//61 22//61 55//61
f 24//62 22//62 54//62
f 22//63 21//63 55//63
f 55//64 20//64 56//64
f 21//65 20//65 55//65
f 56//66 19//66 57//66
f 20//67 19//67 56//67
f 57//68 18//68 58//68
f 19//69 18//69 57//69
f 58//70 17//70 59//70
f 18//71 17//71 58//71
f 59//72 10//72 60//72
f 17//73 10//73 59//73
f 10//74 9//74 60//74
f 60//75 9//75 61//75
f 9//76 8//76 61//76
f 61//77 8//77 4//77
f 8//78 1//78 4//78
f 4//79 3//79 62//79
f 58//80 59//80 60//80
f 58//81 60//81 61//81
f 57//82 61//82 4//82
f 57//83 58//83 61//83
f 63//84 64//84 62//84
f 63//85 62//85 3//85
f 56//86 57//86 4//86
f 55//87 56//87 4//87
f 50//88 51//88 52//88
f 49//89 50//89 52//89
f 48//90 52//90 53//90
f 48//91 53//91 54//91
f 48//92 54//92 55//92
f 48//93 49//93 52//93
f 48//94 55//94 4//94
f 47//95 48//95 4//95
f 65//96 64//96 63//96
f 66//97 65//97 67//97
f 66//98 68//98 69//98
f 66//99 69//99 65//99
f 70//100 67//100 71//100
f 70//101 71//101 72//101
f 73//102 74//102 66//102
f 73//103 66//103 67//103
f 75//104 70//104 76//104
f 75//105 67//105 70//105
f 77//106 78//106 73//106
f 79//107 73//107 67//107
f 79//108 77//108 73//108
f 79//109 75//109 80//109
f 79//110 67//110 75//110
f 69//111 64//111 65//111
f 62//112 47//112 4//112
f 2//113 5//113 3//113
f 3//114 5//114 63//114
f 5//115 27//115 63//115
f 63//116 27//116 65//116
f 27//117 29//117 65//117
f 65//118 29//118 67//118
f 29//119 28//119 67//119
f 67//120 30//120 71//120
f 28//121 30//121 67//121
f 71//122 32//122 72//122
f 30//123 32//123 71//123
f 72//124 33//124 70//124
f 32//125 33//125 72//125
f 70//126 34//126 76//126
f 33//127 34//127 70//127
f 76//128 35//128 75//128
f 34//129 35//129 76//129
f 75//130 39//130 80//130
f 35//131 39//131 75//131
f 80//132 42//132 79//132
f 39//133 42//133 80//133
f 79//134 44//134 77//134
f 42//135 44//135 79//135
f 44//136 46//136 77//136
f 77//137 43//137 78//137
f 46//138 43//138 77//138
f 78//139 40//139 73//139
f 43//140 40//140 78//140
f 40//141 36//141 73//141
f 73//142 38//142 74//142
f 36//143 38//143 73//143
f 74//144 37//144 66//144
f 38//145 37//145 74//145
f 66//146 41//146 68//146
f 37//147 41//147 66//147
f 41//148 45//148 68//148
f 68//149 45//149 69//149
f 45//150 31//150 69//150
f 69//151 31//151 64//151
f 31//152 7//152 64//152
f 7//153 6//153 64//153
f 64//154 6//154 62//154
f 16//155 47//155 62//155
f 6//156 16//156 62//156
`;

        // Parameters for each type
        const containerParams = {
            width: 200,
            depth: 80,
            height: 40,
            divisions: 2,
            depthDivisions: 1,
            wallThickness: 2.0,
            addLid: true,
            clipRotationX: -90,
            clipRotationY: 0,
            clipRotationZ: 0
        };
        
        const holeHangerParams = {
            width: 200,
            depth: 30,
            stripHeight: 20,
            holeCount: 3,
            wallThickness: 2.0,
            holes: [] // Individual parameters for each hole
        };
        
        // Initialize holes array
        function initializeHoles() {
            holeHangerParams.holes = [];
            for (let i = 0; i < holeHangerParams.holeCount; i++) {
                holeHangerParams.holes.push({
                    width: 15,   // Circle diameter
                    height: 15,  // Same as width = circle
                    offset: holeHangerParams.depth / 2  // Centered on shelf depth
                });
            }
        }
        initializeHoles();
        
        const hookHangerParams = {
            backWidth: 40,
            hookDepth: 40,
            hookHeight: 30,
            hookThickness: 6,
            tipDiameter: 8,
            backHeight: 40,
            wallThickness: 2.0
        };
        
        // NEW TYPES - Universal accessories
        
        const simpleHookParams = {
            hookDepth: 40,           // Ширина крючка (2*R полукруга)
            legHeight: 30,           // Высота вертикальной ноги
            hookRadius: 12,          // R - радиус изгиба (НЕ используется если hookDepth активен)
            profileThickness: 3,     // толщина профиля
            hookThickness: 6,        // ширина экструдирования
            backHeight: 30,
            backWidth: 30
        };
        
        const doubleHookParams = {
            hookDepth: 40,           // Ширина крючка
            legHeight: 30,           // Высота вертикальной ноги
            hookRadius: 12,          // R - радиус изгиба
            profileThickness: 3,
            hookThickness: 6,
            hookSpacing: 40,
            backHeight: 30,
            backWidth: 80
        };
        
        const simpleShelfParams = {
            width: 160,
            depth: 60,
            thickness: 3,
            backHeight: 25
        };
        
        const penHolderParams = {
            width: 120,
            depth: 40,
            holeCount: 6,
            holeDiameter: 12,
            baseThickness: 3,
            wallHeight: 40,
            backHeight: 25
        };
        
        const toolHolderParams = {
            width: 50,
            gripWidth: 25,
            gripDepth: 40,
            gripHeight: 30,
            backHeight: 30
        };
        
        const phoneStandParams = {
            width: 90,
            depth: 80,
            angle: 65,
            thickness: 3,
            lipHeight: 15,
            backHeight: 30
        };
        
        function switchType(type) {
            currentType = type;
            
            // Update active tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-type="${type}"]`).classList.add('active');
            
            // Hide all control panels
            document.getElementById('containerControls').classList.add('hidden');
            document.getElementById('simpleHookControls').classList.add('hidden');
            document.getElementById('doubleHookControls').classList.add('hidden');
            document.getElementById('holeHangerControls').classList.add('hidden');
            document.getElementById('hookHangerControls').classList.add('hidden');
            
            // Show controls for selected type
            if (type === 'container') {
                document.getElementById('containerControls').classList.remove('hidden');
            } else if (type === 'simpleHook') {
                document.getElementById('simpleHookControls').classList.remove('hidden');
            } else if (type === 'doubleHook') {
                document.getElementById('doubleHookControls').classList.remove('hidden');
            } else if (type === 'holeHanger') {
                document.getElementById('holeHangerControls').classList.remove('hidden');
            } else if (type === 'hookHanger') {
                document.getElementById('hookHangerControls').classList.remove('hidden');
            }
            
            updateModel();
            requestAnimationFrame(snapButtonsToGrid);
        }
        
        function snapButtonsToGrid() {
            const gridSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-size'));
            document.querySelectorAll('.control-panel:not(.hidden) .btn-group').forEach(group => {
                group.style.marginTop = '0';
                const rect = group.getBoundingClientRect();
                const scrollY = window.scrollY;
                const absTop = rect.top + scrollY;
                const remainder = absTop % gridSize;
                if (remainder > 1) {
                    group.style.marginTop = (gridSize - remainder) + 'px';
                }
            });
        }
        
        // --- Material Helpers ---
        function createMainMaterial() {
            return new THREE.MeshPhysicalMaterial({
                color: 0xff6600,
                roughness: 0.75,
                metalness: 0.0,
                clearcoat: 0.05,
                clearcoatRoughness: 0.9,
                envMapIntensity: 0.3
            });
        }
        
        function createClipMaterial() {
            return new THREE.MeshPhysicalMaterial({
                color: 0xe55a00,
                roughness: 0.8,
                metalness: 0.0,
                clearcoat: 0.05,
                clearcoatRoughness: 0.9,
                envMapIntensity: 0.3
            });
        }
        
        let edgeGroup;
        
        // Initialize Three.js scene
        function init() {
            const canvas = document.getElementById('canvas');
            
            scene = new THREE.Scene();
            
            // Subtle fog for depth
            scene.fog = new THREE.FogExp2(0x001f3f, 0.0008);
            
            camera = new THREE.PerspectiveCamera(50, canvas.parentElement.clientWidth / 600, 0.1, 2000);
            camera.position.set(300, 220, 480);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.parentElement.clientWidth, 600);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.9;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            // --- Lighting Setup ---
            
            // Hemisphere light - cool tones to keep orange pure
            const hemiLight = new THREE.HemisphereLight(0xccddff, 0x112233, 0.4);
            scene.add(hemiLight);
            
            // Key light - neutral white, from top-right, with shadows
            const keyLight = new THREE.DirectionalLight(0xffffff, 0.75);
            keyLight.position.set(200, 300, 200);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 10;
            keyLight.shadow.camera.far = 1000;
            keyLight.shadow.camera.left = -300;
            keyLight.shadow.camera.right = 300;
            keyLight.shadow.camera.top = 300;
            keyLight.shadow.camera.bottom = -300;
            keyLight.shadow.bias = -0.001;
            keyLight.shadow.radius = 4;
            scene.add(keyLight);
            
            // Fill light - cool blue, from the left
            const fillLight = new THREE.DirectionalLight(0xaabbff, 0.4);
            fillLight.position.set(-150, 100, 100);
            scene.add(fillLight);
            
            // Rim light - cool blue accent, from behind for contrast
            const rimLight = new THREE.DirectionalLight(0x6688cc, 0.45);
            rimLight.position.set(-50, 80, -200);
            scene.add(rimLight);
            
            // Subtle bottom bounce
            const bounceLight = new THREE.DirectionalLight(0x334466, 0.2);
            bounceLight.position.set(0, -100, 50);
            scene.add(bounceLight);
            
            // OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;
            controls.maxPolarAngle = Math.PI / 2 + 0.1;
            controls.minDistance = 50;
            controls.maxDistance = 1000;
            
            // Stop auto-rotate on interaction, resume after delay
            let autoRotateTimeout;
            controls.addEventListener('start', () => {
                controls.autoRotate = false;
                clearTimeout(autoRotateTimeout);
            });
            controls.addEventListener('end', () => {
                autoRotateTimeout = setTimeout(() => {
                    controls.autoRotate = true;
                }, 3000);
            });
            
            // Setup tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const type = tab.dataset.type;
                    switchType(type);
                });
            });
            
            // Handle resize
            window.addEventListener('resize', () => {
                const w = canvas.parentElement.clientWidth;
                camera.aspect = w / 600;
                camera.updateProjectionMatrix();
                renderer.setSize(w, 600);
            });
            
            updateModel();
            animate();
            requestAnimationFrame(snapButtonsToGrid);
        }
        
        function enableShadows(obj) {
            obj.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        }
        
        function addEdgeHighlights(obj) {
            // disabled
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        
        // OBJ parsing function
        function parseOBJFile(objText) {
            const lines = objText.split('\n');
            const vertices = [];
            const faces = [];
            
            for (const line of lines) {
                const parts = line.trim().split(/\s+/);
                if (parts[0] === 'v') {
                    vertices.push([
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    ]);
                } else if (parts[0] === 'f') {
                    const faceIndices = [];
                    for (let i = 1; i < parts.length; i++) {
                        const indexPart = parts[i].split('//')[0];
                        faceIndices.push(parseInt(indexPart) - 1);
                    }
                    faces.push(faceIndices);
                }
            }
            
            return { vertices, faces };
        }
        
        // Transform clip geometry with rotations
        function transformClipGeometry(clipObj, position, rotY, rotX, rotZ) {
            const transformedVertices = clipObj.vertices.map(v => {
                let [x, y, z] = v;
                
                // Apply rotations
                // Rotate around Y
                let cosY = Math.cos(rotY);
                let sinY = Math.sin(rotY);
                let tx = x * cosY - z * sinY;
                let tz = x * sinY + z * cosY;
                x = tx;
                z = tz;
                
                // Rotate around X
                let cosX = Math.cos(rotX);
                let sinX = Math.sin(rotX);
                let ty = y * cosX - z * sinX;
                tz = y * sinX + z * cosX;
                y = ty;
                z = tz;
                
                // Rotate around Z
                let cosZ = Math.cos(rotZ);
                let sinZ = Math.sin(rotZ);
                tx = x * cosZ - y * sinZ;
                ty = x * sinZ + y * cosZ;
                x = tx;
                y = ty;
                
                // Apply position
                return [
                    x + position[0],
                    y + position[1],
                    z + position[2]
                ];
            });
            
            return {
                vertices: transformedVertices,
                faces: clipObj.faces
            };
        }
        
        // Update model based on current type
        let animationId = null;
        
        function animateModelIn(model) {
            if (animationId) cancelAnimationFrame(animationId);
            model.scale.set(0.01, 0.01, 0.01);
            const start = performance.now();
            const duration = 400;
            
            function step(now) {
                const t = Math.min((now - start) / duration, 1);
                // easeOutBack for a satisfying pop
                const c1 = 1.70158;
                const c3 = c1 + 1;
                const ease = 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
                model.scale.set(ease, ease, ease);
                if (t < 1) {
                    animationId = requestAnimationFrame(step);
                } else {
                    animationId = null;
                }
            }
            animationId = requestAnimationFrame(step);
        }
        
        function updateModel() {
            // Clear existing model
            if (currentModel) {
                scene.remove(currentModel);
                currentModel.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            if (edgeGroup) {
                scene.remove(edgeGroup);
                edgeGroup = null;
            }
            
            // Create new model based on type
            if (currentType === 'container') {
                currentModel = createContainer();
                camera.position.set(300, 220, 480);
            } else if (currentType === 'simpleHook') {
                currentModel = createSimpleHook();
                camera.position.set(100, 80, 180);
            } else if (currentType === 'doubleHook') {
                currentModel = createDoubleHook();
                camera.position.set(150, 80, 220);
            } else if (currentType === 'holeHanger') {
                currentModel = createHoleHanger();
                camera.position.set(200, 100, 350);
            }
            
            if (currentModel) {
                enableShadows(currentModel);
                scene.add(currentModel);
                addEdgeHighlights(currentModel);
                animateModelIn(currentModel);
            }
            
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        
        // Create Container with compartments and lid
        function createContainer() {
            const params = containerParams;
            const group = new THREE.Group();
            
            const material = createMainMaterial();
            
            const w = params.width;
            const d = params.depth;
            const h = params.height;
            const t = params.wallThickness;
            
            // Bottom
            const bottom = new THREE.Mesh(
                new THREE.BoxGeometry(w, t, d),
                material
            );
            bottom.position.set(0, t / 2, 0);
            group.add(bottom);
            
            // Back wall
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(w, h, t),
                material
            );
            back.position.set(0, h / 2, -d / 2 + t / 2);
            group.add(back);
            
            // Front wall
            const front = new THREE.Mesh(
                new THREE.BoxGeometry(w, h, t),
                material
            );
            front.position.set(0, h / 2, d / 2 - t / 2);
            group.add(front);
            
            // Left wall
            const left = new THREE.Mesh(
                new THREE.BoxGeometry(t, h, d),
                material
            );
            left.position.set(-w / 2 + t / 2, h / 2, 0);
            group.add(left);
            
            // Right wall
            const right = new THREE.Mesh(
                new THREE.BoxGeometry(t, h, d),
                material
            );
            right.position.set(w / 2 - t / 2, h / 2, 0);
            group.add(right);
            
            // Width dividers
            const divs = params.divisions;
            if (divs > 1) {
                const divWidth = w / divs;
                for (let i = 1; i < divs; i++) {
                    const divider = new THREE.Mesh(
                        new THREE.BoxGeometry(t, h, d - t * 2),
                        material
                    );
                    divider.position.set(-w / 2 + divWidth * i, h / 2, 0);
                    group.add(divider);
                }
            }
            
            // Depth dividers
            const depthDivs = params.depthDivisions;
            if (depthDivs > 1) {
                const divDepth = d / depthDivs;
                for (let i = 1; i < depthDivs; i++) {
                    const divider = new THREE.Mesh(
                        new THREE.BoxGeometry(w - t * 2, h, t),
                        material
                    );
                    divider.position.set(0, h / 2, -d / 2 + divDepth * i);
                    group.add(divider);
                }
            }
            
            // External rails for lid
            const railHeight = 3;
            const leftRail = new THREE.Mesh(
                new THREE.BoxGeometry(t, railHeight, d),
                material
            );
            leftRail.position.set(-w / 2 - t / 2, h - railHeight / 2, 0);
            group.add(leftRail);
            
            const rightRail = new THREE.Mesh(
                new THREE.BoxGeometry(t, railHeight, d),
                material
            );
            rightRail.position.set(w / 2 + t / 2, h - railHeight / 2, 0);
            group.add(rightRail);
            
            // SKÅDIS clips - 40mm spacing
            const clipOBJ = parseOBJFile(clipObjData);
            const clipSpacing = 40;
            const numClips = Math.max(1, Math.floor((w - clipSpacing) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = (w - totalClipWidth) / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            const clipMaterial = createClipMaterial();
            
            for (let i = 0; i < numClips; i++) {
                const clipX = -w / 2 + startOffset + (clipSpacing * i) + 15.65;  // Смещение вправо на 15.65мм
                // Position clips: 20mm closer to object, 10mm lower
                // Back wall's outer face is at -d/2
                const clipPos = [clipX, h - clipHeight - 3 - 10, -d / 2 + 9];
                
                // NO rotation on Y axis
                const rotY = 0 * Math.PI / 180;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0 * Math.PI / 180;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, clipMaterial);
                group.add(clipMesh);
            }
            
            // Create lid if enabled
            if (params.addLid) {
                const lidGroup = createLid();
                group.add(lidGroup);
            }
            
            return group;
        }
        
        // Create sliding lid for container
        function createLid() {
            const params = containerParams;
            const material = createMainMaterial();
            
            const w = params.width;
            const d = params.depth;
            const h = params.height;
            const t = params.wallThickness;
            
            const lidGroup = new THREE.Group();
            const lidOffsetY = h + 40;
            const lidOffsetX = 0;
            
            const lidWallHeight = 5;
            const railHeight = 3;
            const flangeWidth = 5;
            const flangeThickness = t;
            const gapAboveFlange = railHeight + 1;
            
            // Top panel
            const topPanel = new THREE.Mesh(
                new THREE.BoxGeometry(w + t * 2, t, d),
                material
            );
            topPanel.position.set(lidOffsetX, lidOffsetY - t / 2, 0);
            lidGroup.add(topPanel);
            
            // Left side wall
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(t, lidWallHeight, d),
                material
            );
            leftWall.position.set(
                lidOffsetX - w / 2 - t / 2,
                lidOffsetY - t - lidWallHeight / 2,
                0
            );
            lidGroup.add(leftWall);
            
            // Left internal flange
            const leftFlange = new THREE.Mesh(
                new THREE.BoxGeometry(flangeWidth, flangeThickness, d),
                material
            );
            leftFlange.position.set(
                lidOffsetX - w / 2 - t + flangeWidth / 2,
                lidOffsetY - t - gapAboveFlange - flangeThickness / 2,
                0
            );
            lidGroup.add(leftFlange);
            
            // Right side wall
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(t, lidWallHeight, d),
                material
            );
            rightWall.position.set(
                lidOffsetX + w / 2 + t / 2,
                lidOffsetY - t - lidWallHeight / 2,
                0
            );
            lidGroup.add(rightWall);
            
            // Right internal flange
            const rightFlange = new THREE.Mesh(
                new THREE.BoxGeometry(flangeWidth, flangeThickness, d),
                material
            );
            rightFlange.position.set(
                lidOffsetX + w / 2 + t - flangeWidth / 2,
                lidOffsetY - t - gapAboveFlange - flangeThickness / 2,
                0
            );
            lidGroup.add(rightFlange);
            
            return lidGroup;
        }

        
        // Create Hole Hanger - back wall + bottom strip with holes
        function createHoleHanger() {
            const params = holeHangerParams;
            const group = new THREE.Group();
            
            const material = createMainMaterial();
            
            const w = params.width;
            const d = params.depth;
            const stripH = params.stripHeight;
            const t = params.wallThickness;
            
            // Back wall
            const backHeight = 30;
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(w, backHeight, t),
                material
            );
            back.position.set(0, backHeight / 2, -d / 2 + t / 2);
            group.add(back);
            
            // Bottom strip with holes
            const strip = createStripWithHoles(params, material);
            group.add(strip);
            
            // SKÅDIS clips - same as container
            const clipOBJ = parseOBJFile(clipObjData);
            const clipSpacing = 40;
            const numClips = Math.max(1, Math.floor((w - clipSpacing) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = (w - totalClipWidth) / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            const clipMaterial = createClipMaterial();
            
            for (let i = 0; i < numClips; i++) {
                const clipX = -w / 2 + startOffset + (clipSpacing * i) + 15.65;  // Смещение вправо на 15.65мм
                // Position clips: 20mm closer to object, 10mm lower
                const clipPos = [clipX, backHeight - clipHeight - 3 - 10, -d / 2 + 9];
                
                // NO rotation on Y axis
                const rotY = 0 * Math.PI / 180;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0 * Math.PI / 180;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, clipMaterial);
                group.add(clipMesh);
            }
            
            return group;
        }
        
        // Create bottom strip with oval holes - HORIZONTAL bottom plate with INDIVIDUAL hole params
        function createStripWithHoles(params, material) {
            const w = params.width;
            const d = params.depth;
            const stripH = params.stripHeight;
            const t = params.wallThickness;
            const holeCount = params.holeCount;
            
            const group = new THREE.Group();
            const spacing = w / (holeCount + 1);
            
            // Create HORIZONTAL bottom plate shape in XZ plane
            const shape = new THREE.Shape();
            shape.moveTo(-w / 2, -d / 2);
            shape.lineTo(w / 2, -d / 2);
            shape.lineTo(w / 2, d / 2);
            shape.lineTo(-w / 2, d / 2);
            shape.lineTo(-w / 2, -d / 2);
            
            // Add oval holes - each with INDIVIDUAL parameters
            for (let i = 0; i < holeCount; i++) {
                const hole = params.holes[i];
                const x = -w / 2 + spacing * (i + 1);
                const z = -d / 2 + hole.offset;
                
                const holePath = new THREE.Path();
                const segments = 32;
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    const hx = x + Math.cos(angle) * (hole.width / 2);
                    const hz = z + Math.sin(angle) * (hole.height / 2);
                    if (j === 0) {
                        holePath.moveTo(hx, hz);
                    } else {
                        holePath.lineTo(hx, hz);
                    }
                }
                shape.holes.push(holePath);
            }
            
            // Extrude horizontally with thickness t
            const extrudeSettings = {
                depth: t,
                bevelEnabled: false
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const strip = new THREE.Mesh(geometry, material);
            // Rotate to make it horizontal and RAISE it so ribs are underneath
            strip.rotation.x = Math.PI / 2;
            strip.position.set(0, stripH + t / 2, 0);  // Raised by stripH
            group.add(strip);
            
            // Add vertical reinforcement ribs UNDER the shelf
            const ribThickness = t * 0.8;
            const ribHeight = stripH;  // Full height to reach the shelf
            
            // Ribs between holes and at edges - VERTICAL ribs UNDER the shelf
            for (let i = 0; i <= holeCount; i++) {
                let ribX;
                if (i === 0) {
                    // Rib at left edge
                    ribX = -w / 2 + spacing * 0.5;
                } else if (i === holeCount) {
                    // Rib at right edge
                    ribX = w / 2 - spacing * 0.5;
                } else {
                    // Rib between holes
                    ribX = -w / 2 + spacing * i + spacing * 0.5;
                }
                
                // Create triangular gusset (right triangle)
                // Vertical leg along back wall, horizontal leg along shelf bottom
                const ribDepth = d - t * 2;
                
                const triangleShape = new THREE.Shape();
                triangleShape.moveTo(0, ribHeight);              // Top at back wall
                triangleShape.lineTo(0, 0);                      // Bottom at back wall (sharp corner)
                triangleShape.lineTo(ribDepth, ribHeight);       // Top at front (under shelf)
                triangleShape.lineTo(0, ribHeight);              // Close the triangle
                
                const extrudeSettings = {
                    depth: ribThickness,
                    bevelEnabled: false
                };
                
                const gussetGeometry = new THREE.ExtrudeGeometry(triangleShape, extrudeSettings);
                gussetGeometry.translate(-ribThickness / 2, 0, 0);  // Center the extrusion
                
                const gusset = new THREE.Mesh(gussetGeometry, material);
                gusset.rotation.y = -Math.PI / 2;  // Rotate to face forward
                gusset.position.set(ribX, 0, -d / 2 + t);  // Position at back wall
                
                group.add(gusset);
            }
            
            return group;
        }

        
        // Create Hook Hanger - back wall + S-shaped hook
        function createHookHanger() {
            const params = hookHangerParams;
            const group = new THREE.Group();
            
            const material = createMainMaterial();
            
            const backW = params.backWidth;
            const hookD = params.hookDepth;
            const hookH = params.hookHeight;
            const thickness = params.hookThickness;
            const tipD = params.tipDiameter;
            const backH = params.backHeight;
            const t = params.wallThickness;
            
            // NO back wall - hook starts directly from clips!
            
            // Create J-hook (fishing hook style)
            const hook = createJHook(params, material);
            group.add(hook);
            
            // SKÅDIS clips - these become the mounting surface
            const clipOBJ = parseOBJFile(clipObjData);
            const clipSpacing = 40;
            const numClips = Math.max(1, Math.floor((backW - clipSpacing) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = (backW - totalClipWidth) / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            const clipMaterial = createClipMaterial();
            
            for (let i = 0; i < numClips; i++) {
                const clipX = -backW / 2 + startOffset + (clipSpacing * i);
                // Position clips: 20mm closer, 10mm lower
                const clipPos = [clipX, backH - clipHeight / 2 - 10, 9];
                
                const rotY = 0 * Math.PI / 180;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0 * Math.PI / 180;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, clipMaterial);
                group.add(clipMesh);
            }
            
            return group;
        }
        
        // Create J-hook (fishing hook style) - ONE solid piece with smooth transitions
        // Create J-hook as ONE continuous tube along smooth curve
        function createJHook(params, material) {
            const group = new THREE.Group();
            const hookD = params.hookDepth;
            const hookH = params.hookHeight;
            const thickness = params.hookThickness;
            const tipD = params.tipDiameter;
            const backH = params.backHeight;
            
            // Create smooth J-curve path
            const curve = new THREE.CurvePath();
            
            const vertLen = hookH * 0.6;
            const horzLen = hookD * 0.7;
            const bendR = thickness * 2;
            const tipR = thickness * 1.5;
            
            // Key points for J-hook
            const p0 = new THREE.Vector3(0, backH, 0);  // Start at clips
            const p1 = new THREE.Vector3(0, backH - vertLen, 0);  // End of vertical
            const p2 = new THREE.Vector3(0, p1.y - bendR, bendR);  // After 90° bend
            const p3 = new THREE.Vector3(0, p2.y, p2.z + horzLen);  // End of horizontal
            const p4 = new THREE.Vector3(0, p3.y - tipR * 0.8, p3.z);  // End of J-tip
            
            // Segment 1: Straight down (vertical)
            curve.add(new THREE.LineCurve3(p0, p1));
            
            // Segment 2: Smooth 90° bend
            curve.add(new THREE.QuadraticBezierCurve3(
                p1,
                new THREE.Vector3(0, p1.y - bendR * 0.6, bendR * 0.4),
                p2
            ));
            
            // Segment 3: Straight horizontal (extending forward)
            curve.add(new THREE.LineCurve3(p2, p3));
            
            // Segment 4: J-tip curve (upward curl)
            curve.add(new THREE.QuadraticBezierCurve3(
                p3,
                new THREE.Vector3(0, p3.y - tipR * 0.6, p3.z),
                p4
            ));
            
            // Create ONE continuous tube along entire curve
            const tubeGeometry = new THREE.TubeGeometry(
                curve,
                64,  // tubular segments (smoothness)
                thickness / 2,  // radius
                16,  // radial segments
                false  // not closed
            );
            
            const hookTube = new THREE.Mesh(tubeGeometry, material);
            group.add(hookTube);
            
            // Add safety ball at tip
            const ballTip = new THREE.Mesh(
                new THREE.SphereGeometry(tipD / 2, 16, 16),
                material
            );
            ballTip.position.copy(p4);
            group.add(ballTip);
            
            return group;
        }
        
        // HELPER: Add SKÅDIS clips to any accessory
        function addSkadisClips(group, width, depth, backHeight, material) {
            const clipOBJ = parseOBJFile(clipObjData);
            const clipSpacing = 40;
            const numClips = Math.max(1, Math.floor((width - clipSpacing) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = (width - totalClipWidth) / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            for (let i = 0; i < numClips; i++) {
                const clipX = -width / 2 + startOffset + (clipSpacing * i);  // БЕЗ смещения
                // Position clips: 20mm closer to object, 10mm lower
                const clipPos = [clipX, backHeight - clipHeight - 3 - 10, -depth / 2 + 9];
                
                // NO rotation on Y axis (was causing flip)
                const rotY = 0 * Math.PI / 180;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, material);
                group.add(clipMesh);
            }
        }
        
        // Add clips specifically for hooks (positioned on the left leg)
        function addHookClips(group, hookDepth, legHeight, material, hookThickness, numHooks = 1, hookSpacing = 0) {
            const clipOBJ = parseOBJFile(clipObjData);
            const R = hookDepth / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            // For single hook or multiple hooks
            for (let i = 0; i < numHooks; i++) {
                let clipZ, clipX, clipY;
                
                if (numHooks === 1) {
                    // Single hook - clip centered on hook
                    // Hook is now centered at X=0 (symmetric extrusion)
                    clipX = 15.65;  // Оригинальное значение (было идеально)
                    clipZ = -R + 9;  // 9mm offset from leg center (-R)
                    
                    // FIXED: Clip Y position independent of legHeight
                    // Fixed distance from top of leg (Y=0)
                    clipY = -(clipHeight + 8);
                } else {
                    // Double hook - clips on each left leg (используется другая функция)
                    const hookX = (hookSpacing / 2 - 40) * (i === 0 ? -1 : 1);
                    clipX = hookX + 15.65;
                    clipZ = -R + 9;  // 9mm offset from leg center
                    clipY = -(clipHeight + 8);
                }
                
                const clipPos = [clipX, clipY, clipZ];
                
                // Rotate clip to attach to the leg
                // rotY = 0 (no rotation) since hook is already rotated -90°
                const rotY = 0;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, material);
                group.add(clipMesh);
            }
        }
        
        // Add clips for Double Hook with fixed spacing
        function addDoubleHookClips(group, hookDepth, legHeight, material, hookThickness, hookSpacing) {
            const R = hookDepth / 2;
            
            // Calculate leg width
            const legWidth = hookSpacing + hookThickness;
            const clipSpacing = 40;  // Fixed SKÅDIS spacing
            
            // Calculate number of clips
            const numClips = Math.max(1, Math.floor((legWidth - 20) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = -totalClipWidth / 2;
            
            const clipOBJ = parseOBJFile(clipObjData);
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            for (let i = 0; i < numClips; i++) {
                const clipX = startOffset + (clipSpacing * i) + 15.65;  // Смещение вправо на 15.65мм
                const clipZ = -R + 9;
                const clipY = -(clipHeight + 8);
                
                const clipPos = [clipX, clipY, clipZ];
                
                const rotY = 0;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, material);
                group.add(clipMesh);
            }
        }
        
        // NEW ACCESSORY TYPES
        
        // Simple Hook - fishing hook profile extruded
        function createSimpleHook() {
            const params = simpleHookParams;
            const group = new THREE.Group();
            
            const material = createMainMaterial();
            
            // ПАРАМЕТРЫ:
            const R = params.hookDepth / 2;              // Радиус = половина ширины
            const legHeight = params.legHeight || 30;    // Высота вертикальной ноги
            const t = params.profileThickness || 3;      // Толщина профиля
            
            // 2D ПРОФИЛЬ - полукруг вверх ногами + ОДНА вертикальная нога (слева)
            const shape = new THREE.Shape();
            
            // ВНЕШНИЙ контур
            // 1. Вертикальная нога сверху (ТОЛЬКО СЛЕВА)
            shape.moveTo(-R, 0);
            shape.lineTo(-R, -legHeight);
            
            // 2. Полукруг вверх ногами (дыркой вниз)
            shape.absarc(0, -legHeight, R, Math.PI, 0, false);
            
            // 3. Конец полукруга справа (БЕЗ ноги)
            
            // ВНУТРЕННИЙ контур (обратный путь)
            // 4. Идем по краю (справа)
            shape.lineTo(R - t, -legHeight);
            
            // 5. Внутренний полукруг
            shape.absarc(0, -legHeight, R - t, 0, Math.PI, true);
            
            // 6. Внутренняя сторона левой ноги
            shape.lineTo(-R + t, 0);
            shape.lineTo(-R, 0);
            
            // ЭКСТРУДИРОВАНИЕ для создания толщины (ширины)
            const extrudeSettings = {
                depth: params.hookThickness || 6,
                bevelEnabled: false
            };
            
            const hookGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // ЦЕНТРИРОВАНИЕ: сдвигаем геометрию чтобы экструзия была симметричной
            // Вместо [0, hookThickness] будет [-hookThickness/2, +hookThickness/2]
            hookGeometry.translate(0, 0, -params.hookThickness / 2);
            
            const hook = new THREE.Mesh(hookGeometry, material);
            
            // Поворот крючка - 180° в плоскости пола (вокруг Y)
            hook.rotation.y = -Math.PI / 2;  // -90° (вместо +90°) = поворот в другую сторону
            // position.x больше не нужен - геометрия уже центрирована
            group.add(hook);
            
            // КРЕПЛЕНИЯ SKÅDIS - на левой ноге
            addHookClips(group, params.hookDepth, legHeight, material, params.hookThickness, 1);
            
            return group;
        }
        
        // Double Hook - two fishing hook profiles extruded
        function createDoubleHook() {
            const params = doubleHookParams;
            const group = new THREE.Group();
            
            const material = createMainMaterial();
            
            // ПАРАМЕТРЫ:
            const R = params.hookDepth / 2;              // Радиус = половина ширины
            const legHeight = params.legHeight || 30;    // Высота вертикальной ноги
            const t = params.profileThickness || 3;      // Толщина профиля
            
            // Создаем два крючка БЕЗ НОГ (только полукруги)
            for (let side = -1; side <= 1; side += 2) {
                const hookX = (params.hookSpacing / 2) * side;
                
                // 2D ПРОФИЛЬ - ТОЛЬКО полукруг (БЕЗ ноги)
                const shape = new THREE.Shape();
                
                // ВНЕШНИЙ контур - только полукруг
                shape.moveTo(-R, -legHeight);
                shape.absarc(0, -legHeight, R, Math.PI, 0, false);
                
                // ВНУТРЕННИЙ контур - внутренний полукруг
                shape.lineTo(R - t, -legHeight);
                shape.absarc(0, -legHeight, R - t, 0, Math.PI, true);
                shape.lineTo(-R, -legHeight);
                
                // ЭКСТРУДИРОВАНИЕ
                const extrudeSettings = {
                    depth: params.hookThickness || 6,
                    bevelEnabled: false
                };
                
                const hookGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                
                // ЦЕНТРИРОВАНИЕ: симметричная экструзия
                hookGeometry.translate(0, 0, -params.hookThickness / 2);
                
                const hook = new THREE.Mesh(hookGeometry, material);
                
                hook.rotation.y = -Math.PI / 2;
                hook.position.x = hookX;
                group.add(hook);
            }
            
            // ОБЩАЯ НОГА - широкая вертикальная панель
            // После поворота крючка на -90°, его ширина вдоль X = hookThickness
            const legWidth = params.hookSpacing + params.hookThickness;
            const legGeometry = new THREE.BoxGeometry(
                legWidth,           // Ширина (вдоль X)
                legHeight,          // Высота (вдоль Y)
                t                   // Толщина (вдоль Z) - такая же как profileThickness
            );
            
            // Сдвигаем геометрию чтобы верх был в Y=0
            legGeometry.translate(0, -legHeight / 2, 0);
            
            const leg = new THREE.Mesh(legGeometry, material);
            leg.position.x = 0;           // По центру между крючками
            leg.position.y = 0;           // Верх в Y=0
            leg.position.z = -R + t / 2;  // Задняя грань на -R, передняя выступает к крючкам
            group.add(leg);
            
            // КРЕПЛЕНИЯ SKÅDIS - используем специальную функцию для Double Hook
            addDoubleHookClips(group, params.hookDepth, legHeight, material, params.hookThickness, params.hookSpacing);
            
            return group;
        }
        
        // Simple Shelf - flat shelf
        function createSimpleShelf() {
            const params = simpleShelfParams;
            const group = new THREE.Group();
            
            const material = createMainMaterial();
            
            // Shelf platform
            const shelf = new THREE.Mesh(
                new THREE.BoxGeometry(params.width, params.thickness, params.depth),
                material
            );
            shelf.position.set(0, params.thickness / 2, params.depth / 4);
            group.add(shelf);
            
            // Front lip
            const lip = new THREE.Mesh(
                new THREE.BoxGeometry(params.width, 5, params.thickness),
                material
            );
            lip.position.set(0, 5 / 2, params.depth / 2 - params.thickness / 2);
            group.add(lip);
            
            // Side supports
            for (let side = -1; side <= 1; side += 2) {
                const support = new THREE.Mesh(
                    new THREE.BoxGeometry(params.thickness, params.backHeight, params.depth * 0.6),
                    material
                );
                support.position.set(side * (params.width / 2 - params.thickness / 2), params.backHeight / 2, params.depth * 0.15);
                group.add(support);
            }
            
            // Add clips - INLINE VERSION WITH OFFSET
            const clipOBJ = parseOBJFile(clipObjData);
            const clipSpacing = 40;
            const numClips = Math.max(1, Math.floor((params.width - clipSpacing) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = (params.width - totalClipWidth) / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            for (let i = 0; i < numClips; i++) {
                const clipX = -params.width / 2 + startOffset + (clipSpacing * i) + 15.65;  // Смещение вправо на 15.65мм
                const clipPos = [clipX, params.backHeight - clipHeight - 3 - 10, -params.depth * 0.3 / 2 + 9];
                
                const rotY = 0;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, material);
                group.add(clipMesh);
            }
            
            return group;
        }
        
        // Pen Holder - vertical holes for pens/pencils
        function createPenHolder() {
            const params = penHolderParams;
            const group = new THREE.Group();
            
            const material = createMainMaterial();
            
            const spacing = params.width / (params.holeCount + 1);
            
            // Create base with holes
            const shape = new THREE.Shape();
            shape.moveTo(-params.width / 2, -params.depth / 2);
            shape.lineTo(params.width / 2, -params.depth / 2);
            shape.lineTo(params.width / 2, params.depth / 2);
            shape.lineTo(-params.width / 2, params.depth / 2);
            shape.lineTo(-params.width / 2, -params.depth / 2);
            
            // Add holes
            for (let i = 0; i < params.holeCount; i++) {
                const x = -params.width / 2 + spacing * (i + 1);
                const holePath = new THREE.Path();
                const segments = 24;
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    const hx = x + Math.cos(angle) * (params.holeDiameter / 2);
                    const hz = Math.sin(angle) * (params.holeDiameter / 2);
                    if (j === 0) holePath.moveTo(hx, hz);
                    else holePath.lineTo(hx, hz);
                }
                shape.holes.push(holePath);
            }
            
            const base = new THREE.Mesh(
                new THREE.ExtrudeGeometry(shape, { depth: params.baseThickness, bevelEnabled: false }),
                material
            );
            base.rotation.x = Math.PI / 2;
            base.position.y = params.baseThickness / 2;
            group.add(base);
            
            // Back wall
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(params.width, params.wallHeight, params.baseThickness),
                material
            );
            back.position.set(0, params.wallHeight / 2, -params.depth / 2 + params.baseThickness / 2);
            group.add(back);
            
            // Add clips - INLINE WITH +15 OFFSET
            const clipOBJ = parseOBJFile(clipObjData);
            const clipSpacing = 40;
            const numClips = Math.max(1, Math.floor((params.width - clipSpacing) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = (params.width - totalClipWidth) / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            for (let i = 0; i < numClips; i++) {
                const clipX = -params.width / 2 + startOffset + (clipSpacing * i) + 15.65;
                const clipPos = [clipX, params.backHeight - clipHeight - 3 - 10, -params.depth / 2 + 9];
                
                const rotY = 0;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, material);
                group.add(clipMesh);
            }
            
            return group;
        }
        
        // Tool Holder - grip/clamp for tools
        function createToolHolder() {
            const params = toolHolderParams;
            const group = new THREE.Group();
            
            const material = createMainMaterial();
            
            // Base plate
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(params.width, 3, params.gripDepth),
                material
            );
            base.position.y = 1.5;
            group.add(base);
            
            // Grip walls (U-shape)
            const wall1 = new THREE.Mesh(
                new THREE.BoxGeometry(3, params.gripHeight, params.gripDepth),
                material
            );
            wall1.position.set(-params.gripWidth / 2, params.gripHeight / 2, 0);
            group.add(wall1);
            
            const wall2 = new THREE.Mesh(
                new THREE.BoxGeometry(3, params.gripHeight, params.gripDepth),
                material
            );
            wall2.position.set(params.gripWidth / 2, params.gripHeight / 2, 0);
            group.add(wall2);
            
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(params.gripWidth, params.gripHeight, 3),
                material
            );
            back.position.set(0, params.gripHeight / 2, -params.gripDepth / 2 + 1.5);
            group.add(back);
            
            // Add clips
            // Add clips - INLINE WITH +15 OFFSET
            const clipOBJ = parseOBJFile(clipObjData);
            const clipSpacing = 40;
            const numClips = Math.max(1, Math.floor((params.width - clipSpacing) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = (params.width - totalClipWidth) / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            for (let i = 0; i < numClips; i++) {
                const clipX = -params.width / 2 + startOffset + (clipSpacing * i) + 15.65;
                const clipPos = [clipX, params.backHeight - clipHeight - 3 - 10, -params.gripDepth / 2 + 9];
                
                const rotY = 0;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, material);
                group.add(clipMesh);
            }
            
            return group;
        }
        
        // Phone Stand - angled holder
        function createPhoneStand() {
            const params = phoneStandParams;
            const group = new THREE.Group();
            
            const material = createMainMaterial();
            
            const angleRad = params.angle * Math.PI / 180;
            
            // Angled platform
            const platform = new THREE.Mesh(
                new THREE.BoxGeometry(params.width, params.depth, params.thickness),
                material
            );
            platform.rotation.x = angleRad;
            const platformY = params.depth / 2 * Math.sin(angleRad);
            const platformZ = params.depth / 2 * Math.cos(angleRad);
            platform.position.set(0, platformY, platformZ);
            group.add(platform);
            
            // Bottom lip
            const lip = new THREE.Mesh(
                new THREE.BoxGeometry(params.width, params.lipHeight, params.thickness),
                material
            );
            lip.position.set(0, params.lipHeight / 2, params.depth * Math.cos(angleRad) + params.thickness / 2);
            group.add(lip);
            
            // Side supports
            for (let side = -1; side <= 1; side += 2) {
                const support = new THREE.Mesh(
                    new THREE.BoxGeometry(params.thickness, params.backHeight, params.depth * 0.4),
                    material
                );
                support.position.set(side * (params.width / 2 - params.thickness / 2), params.backHeight / 2, params.depth * 0.2);
                group.add(support);
            }
            
            // Add clips
            // Add clips - INLINE WITH +15 OFFSET
            const clipOBJ = parseOBJFile(clipObjData);
            const clipSpacing = 40;
            const numClips = Math.max(1, Math.floor((params.width - clipSpacing) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = (params.width - totalClipWidth) / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            for (let i = 0; i < numClips; i++) {
                const clipX = -params.width / 2 + startOffset + (clipSpacing * i) + 15.65;
                const clipPos = [clipX, params.backHeight - clipHeight - 3 - 10, -params.depth * 0.4 / 2 + 9];
                
                const rotY = 0;
                const rotX = -90 * Math.PI / 180;
                const rotZ = 0;
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                transformedClip.faces.forEach(face => {
                    const startIdx = vertices.length / 3;
                    face.forEach(idx => {
                        const v = transformedClip.vertices[idx];
                        vertices.push(v[0], v[1], v[2]);
                    });
                    if (face.length === 3) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                    } else if (face.length === 4) {
                        indices.push(startIdx, startIdx + 1, startIdx + 2);
                        indices.push(startIdx, startIdx + 2, startIdx + 3);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const clipMesh = new THREE.Mesh(geometry, material);
                group.add(clipMesh);
            }
            
            return group;
        }
        
        // Event handlers for Container controls
        function setupContainerControls() {
            document.getElementById('width').addEventListener('input', (e) => {
                containerParams.width = parseInt(e.target.value);
                document.getElementById('widthValue').textContent = containerParams.width;
                updateModel();
            });
            
            document.getElementById('depth').addEventListener('input', (e) => {
                containerParams.depth = parseInt(e.target.value);
                document.getElementById('depthValue').textContent = containerParams.depth;
                updateModel();
            });
            
            document.getElementById('height').addEventListener('input', (e) => {
                containerParams.height = parseInt(e.target.value);
                document.getElementById('heightValue').textContent = containerParams.height;
                updateModel();
            });
            
            document.getElementById('divisions').addEventListener('input', (e) => {
                containerParams.divisions = parseInt(e.target.value);
                document.getElementById('divisionsValue').textContent = containerParams.divisions;
                updateModel();
            });
            
            document.getElementById('depthDivisions').addEventListener('input', (e) => {
                containerParams.depthDivisions = parseInt(e.target.value);
                document.getElementById('depthDivisionsValue').textContent = containerParams.depthDivisions;
                updateModel();
            });
            
            document.getElementById('wallThickness').addEventListener('input', (e) => {
                containerParams.wallThickness = parseFloat(e.target.value);
                document.getElementById('wallThicknessValue').textContent = containerParams.wallThickness.toFixed(1);
                updateModel();
            });
            
            document.getElementById('addLid').addEventListener('change', (e) => {
                containerParams.addLid = e.target.checked;
                updateModel();
            });
        }
        
        // Event handlers for Hole Hanger controls
        // Generate dynamic hole controls
        function generateHoleControls() {
            const container = document.getElementById('dynamicHoleControls');
            container.innerHTML = '';
            
            for (let i = 0; i < holeHangerParams.holeCount; i++) {
                // Hole section header
                const header = document.createElement('div');
                header.style.marginTop = '40px';
                header.style.marginBottom = '20px';
                header.style.fontSize = '0.85rem';
                header.style.color = 'var(--accent-primary)';
                header.style.textTransform = 'uppercase';
                header.style.letterSpacing = '1px';
                header.textContent = `Hole ${i + 1}`;
                container.appendChild(header);
                
                // Width control
                const widthGroup = document.createElement('div');
                widthGroup.className = 'control-group';
                widthGroup.innerHTML = `
                    <label class="control-label">
                        <span>Width (mm)</span>
                        <span class="control-value" id="hole${i}WidthValue">${holeHangerParams.holes[i].width}</span>
                    </label>
                    <input type="range" id="hole${i}Width" min="8" max="30" value="${holeHangerParams.holes[i].width}" step="1">
                `;
                container.appendChild(widthGroup);
                
                // Height control
                const heightGroup = document.createElement('div');
                heightGroup.className = 'control-group';
                heightGroup.innerHTML = `
                    <label class="control-label">
                        <span>Height (mm)</span>
                        <span class="control-value" id="hole${i}HeightValue">${holeHangerParams.holes[i].height}</span>
                    </label>
                    <input type="range" id="hole${i}Height" min="8" max="30" value="${holeHangerParams.holes[i].height}" step="1">
                `;
                container.appendChild(heightGroup);
                
                // Offset control
                const offsetGroup = document.createElement('div');
                offsetGroup.className = 'control-group';
                offsetGroup.innerHTML = `
                    <label class="control-label">
                        <span>Offset from Back (mm)</span>
                        <span class="control-value" id="hole${i}OffsetValue">${holeHangerParams.holes[i].offset.toFixed(1)}</span>
                    </label>
                    <input type="range" id="hole${i}Offset" min="5" max="${holeHangerParams.depth - 5}" value="${holeHangerParams.holes[i].offset}" step="0.5">
                `;
                container.appendChild(offsetGroup);
                
                // Add event listeners
                (function(index) {
                    document.getElementById(`hole${index}Width`).addEventListener('input', (e) => {
                        holeHangerParams.holes[index].width = parseInt(e.target.value);
                        document.getElementById(`hole${index}WidthValue`).textContent = holeHangerParams.holes[index].width;
                        updateModel();
                    });
                    
                    document.getElementById(`hole${index}Height`).addEventListener('input', (e) => {
                        holeHangerParams.holes[index].height = parseInt(e.target.value);
                        document.getElementById(`hole${index}HeightValue`).textContent = holeHangerParams.holes[index].height;
                        updateModel();
                    });
                    
                    document.getElementById(`hole${index}Offset`).addEventListener('input', (e) => {
                        holeHangerParams.holes[index].offset = parseFloat(e.target.value);
                        document.getElementById(`hole${index}OffsetValue`).textContent = holeHangerParams.holes[index].offset.toFixed(1);
                        updateModel();
                    });
                })(i);
            }
        }
        
        function setupHoleHangerControls() {
            document.getElementById('holeWidth').addEventListener('input', (e) => {
                holeHangerParams.width = parseInt(e.target.value);
                document.getElementById('holeWidthValue').textContent = holeHangerParams.width;
                updateModel();
            });
            
            document.getElementById('holeDepth').addEventListener('input', (e) => {
                holeHangerParams.depth = parseInt(e.target.value);
                document.getElementById('holeDepthValue').textContent = holeHangerParams.depth;
                // Recenter all holes on new depth
                for (let i = 0; i < holeHangerParams.holes.length; i++) {
                    holeHangerParams.holes[i].offset = holeHangerParams.depth / 2;
                }
                generateHoleControls(); // Regenerate UI with updated values
                updateModel();
            });
            
            document.getElementById('stripHeight').addEventListener('input', (e) => {
                holeHangerParams.stripHeight = parseInt(e.target.value);
                document.getElementById('stripHeightValue').textContent = holeHangerParams.stripHeight;
                updateModel();
            });
            
            document.getElementById('holeCount').addEventListener('input', (e) => {
                holeHangerParams.holeCount = parseInt(e.target.value);
                document.getElementById('holeCountValue').textContent = holeHangerParams.holeCount;
                initializeHoles(); // Regenerate holes array
                generateHoleControls(); // Regenerate UI
                updateModel();
                requestAnimationFrame(snapButtonsToGrid);
            });
            
            document.getElementById('holeWallThickness').addEventListener('input', (e) => {
                holeHangerParams.wallThickness = parseFloat(e.target.value);
                document.getElementById('holeWallThicknessValue').textContent = holeHangerParams.wallThickness.toFixed(1);
                updateModel();
            });
            
            // Generate initial hole controls
            generateHoleControls();
        }
        
        // Event handlers for Hook Hanger controls
        function setupHookHangerControls() {
            document.getElementById('hookBackWidth').addEventListener('input', (e) => {
                hookHangerParams.backWidth = parseInt(e.target.value);
                document.getElementById('hookBackWidthValue').textContent = hookHangerParams.backWidth;
                updateModel();
            });
            
            document.getElementById('hookDepth').addEventListener('input', (e) => {
                hookHangerParams.hookDepth = parseInt(e.target.value);
                document.getElementById('hookDepthValue').textContent = hookHangerParams.hookDepth;
                updateModel();
            });
            
            document.getElementById('hookHeight').addEventListener('input', (e) => {
                hookHangerParams.hookHeight = parseInt(e.target.value);
                document.getElementById('hookHeightValue').textContent = hookHangerParams.hookHeight;
                updateModel();
            });
            
            document.getElementById('hookThickness').addEventListener('input', (e) => {
                hookHangerParams.hookThickness = parseInt(e.target.value);
                document.getElementById('hookThicknessValue').textContent = hookHangerParams.hookThickness;
                updateModel();
            });
            
            document.getElementById('tipDiameter').addEventListener('input', (e) => {
                hookHangerParams.tipDiameter = parseInt(e.target.value);
                document.getElementById('tipDiameterValue').textContent = hookHangerParams.tipDiameter;
                updateModel();
            });
            
            document.getElementById('hookBackHeight').addEventListener('input', (e) => {
                hookHangerParams.backHeight = parseInt(e.target.value);
                document.getElementById('hookBackHeightValue').textContent = hookHangerParams.backHeight;
                updateModel();
            });
            
            document.getElementById('hookWallThickness').addEventListener('input', (e) => {
                hookHangerParams.wallThickness = parseFloat(e.target.value);
                document.getElementById('hookWallThicknessValue').textContent = hookHangerParams.wallThickness.toFixed(1);
                updateModel();
            });
        }

        function setupSimpleHookControls() {
            document.getElementById('simpleHookDepth').addEventListener('input', (e) => {
                simpleHookParams.hookDepth = parseInt(e.target.value);
                document.getElementById('simpleHookDepthValue').textContent = simpleHookParams.hookDepth;
                updateModel();
            });
            
            document.getElementById('simpleHookLegHeight').addEventListener('input', (e) => {
                simpleHookParams.legHeight = parseInt(e.target.value);
                document.getElementById('simpleHookLegHeightValue').textContent = simpleHookParams.legHeight;
                updateModel();
            });
            
            document.getElementById('simpleHookExtrusion').addEventListener('input', (e) => {
                simpleHookParams.hookThickness = parseInt(e.target.value);
                document.getElementById('simpleHookExtrusionValue').textContent = simpleHookParams.hookThickness;
                updateModel();
            });
            
            document.getElementById('simpleHookThickness').addEventListener('input', (e) => {
                simpleHookParams.profileThickness = parseFloat(e.target.value);
                document.getElementById('simpleHookThicknessValue').textContent = simpleHookParams.profileThickness;
                updateModel();
            });
        }
        
        function setupDoubleHookControls() {
            document.getElementById('doubleHookDepth').addEventListener('input', (e) => {
                doubleHookParams.hookDepth = parseInt(e.target.value);
                document.getElementById('doubleHookDepthValue').textContent = doubleHookParams.hookDepth;
                updateModel();
            });
            
            document.getElementById('doubleHookLegHeight').addEventListener('input', (e) => {
                doubleHookParams.legHeight = parseInt(e.target.value);
                document.getElementById('doubleHookLegHeightValue').textContent = doubleHookParams.legHeight;
                updateModel();
            });
            
            document.getElementById('doubleHookExtrusion').addEventListener('input', (e) => {
                doubleHookParams.hookThickness = parseInt(e.target.value);
                document.getElementById('doubleHookExtrusionValue').textContent = doubleHookParams.hookThickness;
                updateModel();
            });
            
            document.getElementById('doubleHookSpacing').addEventListener('input', (e) => {
                doubleHookParams.hookSpacing = parseInt(e.target.value);
                document.getElementById('doubleHookSpacingValue').textContent = doubleHookParams.hookSpacing;
                updateModel();
            });
            
            document.getElementById('doubleHookThickness').addEventListener('input', (e) => {
                doubleHookParams.profileThickness = parseFloat(e.target.value);
                document.getElementById('doubleHookThicknessValue').textContent = doubleHookParams.profileThickness;
                updateModel();
            });
        }

        
        // Extract or generate geometry based on current type
        function extractGeometry() {
            // For export, use specialized geometry generation
            if (currentType === 'container') {
                return generateContainerGeometry();
            } else if (currentType === 'holeHanger') {
                return generateHoleHangerGeometry();
            } else if (currentType === 'hookHanger') {
                return generateHookHangerGeometry();
            }
            
            // Fallback: extract from scene
            const geometryData = {
                vertices: [],
                faces: []
            };
            
            if (!currentModel) return geometryData;
            
            let vertexOffset = 0;
            
            currentModel.traverse((child) => {
                if (child instanceof THREE.Mesh && child.geometry) {
                    const geo = child.geometry;
                    const posAttr = geo.attributes.position;
                    const index = geo.index;
                    
                    child.updateMatrixWorld(true);
                    const matrix = child.matrixWorld;
                    
                    const startVertex = geometryData.vertices.length;
                    for (let i = 0; i < posAttr.count; i++) {
                        const v = new THREE.Vector3(
                            posAttr.getX(i),
                            posAttr.getY(i),
                            posAttr.getZ(i)
                        );
                        v.applyMatrix4(matrix);
                        geometryData.vertices.push([v.x, v.y, v.z]);
                    }
                    
                    if (index) {
                        for (let i = 0; i < index.count; i += 3) {
                            geometryData.faces.push([
                                startVertex + index.getX(i),
                                startVertex + index.getX(i + 1),
                                startVertex + index.getX(i + 2)
                            ]);
                        }
                    } else {
                        for (let i = 0; i < posAttr.count; i += 3) {
                            geometryData.faces.push([
                                startVertex + i,
                                startVertex + i + 1,
                                startVertex + i + 2
                            ]);
                        }
                    }
                }
            });
            
            return geometryData;
        }
        
        // Helper function to add box geometry
        function addBoxToGeometry(geometry, cx, cy, cz, width, height, depth) {
            const startIdx = geometry.vertices.length;
            const hw = width / 2, hh = height / 2, hd = depth / 2;
            
            // 8 vertices
            const verts = [
                [cx - hw, cy - hh, cz - hd], // 0
                [cx + hw, cy - hh, cz - hd], // 1
                [cx + hw, cy + hh, cz - hd], // 2
                [cx - hw, cy + hh, cz - hd], // 3
                [cx - hw, cy - hh, cz + hd], // 4
                [cx + hw, cy - hh, cz + hd], // 5
                [cx + hw, cy + hh, cz + hd], // 6
                [cx - hw, cy + hh, cz + hd]  // 7
            ];
            
            verts.forEach(v => geometry.vertices.push(v));
            
            // 12 triangles (6 faces * 2)
            const faces = [
                [0, 1, 2], [0, 2, 3],  // Front
                [5, 4, 7], [5, 7, 6],  // Back
                [4, 0, 3], [4, 3, 7],  // Left
                [1, 5, 6], [1, 6, 2],  // Right
                [3, 2, 6], [3, 6, 7],  // Top
                [4, 5, 1], [4, 1, 0]   // Bottom
            ];
            
            faces.forEach(f => {
                geometry.faces.push([
                    startIdx + f[0],
                    startIdx + f[1],
                    startIdx + f[2]
                ]);
            });
        }
        
        // Generate Container geometry for export
        function generateContainerGeometry() {
            const params = containerParams;
            const w = params.width;
            const d = params.depth;
            const h = params.height;
            const t = params.wallThickness;
            
            const geometry = { vertices: [], faces: [] };
            
            // Bottom
            addBoxToGeometry(geometry, 0, t / 2, 0, w, t, d);
            
            // Walls
            addBoxToGeometry(geometry, 0, h / 2, -d / 2 + t / 2, w, h, t); // Back
            addBoxToGeometry(geometry, 0, h / 2, d / 2 - t / 2, w, h, t);  // Front
            addBoxToGeometry(geometry, -w / 2 + t / 2, h / 2, 0, t, h, d); // Left
            addBoxToGeometry(geometry, w / 2 - t / 2, h / 2, 0, t, h, d);  // Right
            
            // Width dividers
            if (params.divisions > 1) {
                const divWidth = w / params.divisions;
                for (let i = 1; i < params.divisions; i++) {
                    addBoxToGeometry(geometry, -w / 2 + divWidth * i, h / 2, 0, t, h, d - t * 2);
                }
            }
            
            // Depth dividers
            if (params.depthDivisions > 1) {
                const divDepth = d / params.depthDivisions;
                for (let i = 1; i < params.depthDivisions; i++) {
                    addBoxToGeometry(geometry, 0, h / 2, -d / 2 + divDepth * i, w - t * 2, h, t);
                }
            }
            
            // Rails
            addBoxToGeometry(geometry, -w / 2 - t / 2, h - 1.5, 0, t, 3, d);
            addBoxToGeometry(geometry, w / 2 + t / 2, h - 1.5, 0, t, 3, d);
            
            // Add clips
            addClipsToGeometry(geometry, w, d, h, params);
            
            // Add lid if enabled
            if (params.addLid) {
                const lidOffsetY = h + 40;
                addBoxToGeometry(geometry, 0, lidOffsetY - t / 2, 0, w + t * 2, t, d);
                addBoxToGeometry(geometry, -w / 2 - t / 2, lidOffsetY - t - 2.5, 0, t, 5, d);
                addBoxToGeometry(geometry, -w / 2 - t + 2.5, lidOffsetY - t - 4 - t / 2, 0, 5, t, d);
                addBoxToGeometry(geometry, w / 2 + t / 2, lidOffsetY - t - 2.5, 0, t, 5, d);
                addBoxToGeometry(geometry, w / 2 + t - 2.5, lidOffsetY - t - 4 - t / 2, 0, 5, t, d);
            }
            
            return geometry;
        }
        
        // Generate Hole Hanger geometry for export
        function generateHoleHangerGeometry() {
            const params = holeHangerParams;
            const w = params.width;
            const d = params.depth;
            const stripH = params.stripHeight;
            const t = params.wallThickness;
            const backH = 30;
            
            const geometry = { vertices: [], faces: [] };
            
            // Back wall
            addBoxToGeometry(geometry, 0, backH / 2, -d / 2 + t / 2, w, backH, t);
            
            // Bottom strip (simplified without holes for now - full CSG would be needed)
            addBoxToGeometry(geometry, 0, stripH / 2, 0, w, stripH, d);
            
            // Add clips
            addClipsToGeometry(geometry, w, d, backH, { clipRotationX: -90, clipRotationY: 0, clipRotationZ: 0 });
            
            return geometry;
        }
        
        // Generate Hook Hanger geometry for export
        function generateHookHangerGeometry() {
            const params = hookHangerParams;
            const backW = params.backWidth;
            const hookD = params.hookDepth;
            const backH = params.backHeight;
            const t = params.wallThickness;
            
            const geometry = { vertices: [], faces: [] };
            
            // Back wall
            addBoxToGeometry(geometry, 0, backH / 2, -hookD / 2 + t / 2, backW, backH, t);
            
            // Hook (simplified as box for export - full curve would need more complex code)
            const hookThick = params.hookThickness;
            addBoxToGeometry(geometry, 0, params.hookHeight / 2, 0, hookThick, params.hookHeight, hookD * 0.8);
            
            // Add clips
            addClipsToGeometry(geometry, backW, hookD, backH, { clipRotationX: -90, clipRotationY: 0, clipRotationZ: 0 });
            
            return geometry;
        }
        
        // Helper to add clips to geometry
        function addClipsToGeometry(geometry, width, depth, height, params = {}) {
            const clipOBJ = parseOBJFile(clipObjData);
            const clipSpacing = 40;
            const numClips = Math.max(1, Math.floor((width - clipSpacing) / clipSpacing) + 1);
            const totalClipWidth = (numClips - 1) * clipSpacing;
            const startOffset = (width - totalClipWidth) / 2;
            
            const clipMinY = Math.min(...clipOBJ.vertices.map(v => v[1]));
            const clipMaxY = Math.max(...clipOBJ.vertices.map(v => v[1]));
            const clipHeight = clipMaxY - clipMinY;
            
            const rotX = (params.clipRotationX || -90) * Math.PI / 180;
            const rotY = (params.clipRotationY || 0) * Math.PI / 180;
            const rotZ = (params.clipRotationZ || 0) * Math.PI / 180;
            
            for (let i = 0; i < numClips; i++) {
                const clipX = -width / 2 + startOffset + (clipSpacing * i);
                const clipPos = [clipX, height - clipHeight - 3, -depth / 2];
                
                const transformedClip = transformClipGeometry(clipOBJ, clipPos, rotY, rotX, rotZ);
                
                const startIdx = geometry.vertices.length;
                transformedClip.vertices.forEach(v => geometry.vertices.push(v));
                transformedClip.faces.forEach(face => {
                    if (face.length === 3) {
                        geometry.faces.push([
                            startIdx + face[0],
                            startIdx + face[1],
                            startIdx + face[2]
                        ]);
                    } else if (face.length === 4) {
                        geometry.faces.push([
                            startIdx + face[0],
                            startIdx + face[1],
                            startIdx + face[2]
                        ]);
                        geometry.faces.push([
                            startIdx + face[0],
                            startIdx + face[2],
                            startIdx + face[3]
                        ]);
                    }
                });
            }
        }
        
        // Calculate normal for a triangle
        function calculateNormal(v1, v2, v3) {
            const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
            const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
            
            const nx = u[1] * v[2] - u[2] * v[1];
            const ny = u[2] * v[0] - u[0] * v[2];
            const nz = u[0] * v[1] - u[1] * v[0];
            
            const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
            if (len > 0) {
                return [nx / len, ny / len, nz / len];
            }
            return [0, 0, 1];
        }
        
        // Generate STL file
        function generateSTL() {
            const geometry = extractGeometry();
            
            let stl = 'solid model\n';
            
            geometry.faces.forEach(face => {
                const v1 = geometry.vertices[face[0]];
                const v2 = geometry.vertices[face[1]];
                const v3 = geometry.vertices[face[2]];
                
                const normal = calculateNormal(v1, v2, v3);
                
                stl += `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n`;
                stl += '    outer loop\n';
                stl += `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n`;
                stl += `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n`;
                stl += `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n`;
                stl += '    endloop\n';
                stl += '  endfacet\n';
            });
            
            stl += 'endsolid model\n';
            
            downloadFile(stl, `skadis_${currentType}.stl`, 'text/plain');
        }
        
        // Generate 3MF file (simplified - single object)
        function generate3MF() {
            const geometry = extractGeometry();
            
            // Build vertices string
            let verticesXML = '';
            geometry.vertices.forEach(v => {
                verticesXML += `    <vertex x="${v[0].toFixed(3)}" y="${v[1].toFixed(3)}" z="${v[2].toFixed(3)}" />\n`;
            });
            
            // Build triangles string
            let trianglesXML = '';
            geometry.faces.forEach(face => {
                trianglesXML += `    <triangle v1="${face[0]}" v2="${face[1]}" v3="${face[2]}" />\n`;
            });
            
            const modelXML = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02">
  <resources>
    <object id="1" type="model">
      <mesh>
        <vertices>
${verticesXML}        </vertices>
        <triangles>
${trianglesXML}        </triangles>
      </mesh>
    </object>
  </resources>
  <build>
    <item objectid="1" />
  </build>
</model>`;
            
            // Create simple 3MF structure (normally would be a ZIP)
            // For browser compatibility, we'll save as XML with .3mf extension
            downloadFile(modelXML, `skadis_${currentType}.3mf`, 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml');
        }
        
        // Download file helper
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        // Initialize everything on page load
        window.addEventListener('DOMContentLoaded', () => {
            init();
            setupContainerControls();
            setupSimpleHookControls();
            setupDoubleHookControls();
            setupHoleHangerControls();
            setupHookHangerControls();
        });
        
    </script>
</body>
</html>
